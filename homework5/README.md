# Homework 5

## Задача: Контакти

### Първа част: Речник

Да се реализира шаблон на клас `Dictionary` с два типови параметъра `K` и `V`. 
Класът да представя речник, който съдържа редица от ключове от тип `K` и на всеки ключ съпоставя по една стойност от тип `V`. 
Едно примерно представяне би могло да бъде с два масива с една и съща дължина — един с елементи от тип `K` и един с елементи от тип `V`. 
За типа `K` и `V` може да се приеме, че са налични:

*    голяма четворка

*    операция за изход `<<`

*    операции за сравнение `==` и `!=`

*    за типа `К` допълнително са налични операции за наредба `<`, `<=`, `>`, `>=`


За класа да се реализират:

*    голяма четворка

*    добавяне на ключ и съответна на него стойност

*    търсене на стойност по ключ

*    извежда речника на стандартния вход подреден по ключ

*    разширяване на речника при изчерпване на капацитета му

### Втора част: Книга с контакти

Да се създаде клас `Contact`, който съдържа име, телефонен номер (до 10 цифрен), и идентификатор с подходящи конструктор, селектори и мутатори.

Да се създаде клас `ContactBook`, който представя бележник с контакти като набор от три речника, чиито ключове са съответно име, 
телефонен номер и идентификатор, а стойностите са указатели към контакти (`Contact*`).

За този клас да се реализират:

*    добавяне на контакт

*    намиране на контакт по даден критерий (име, телефонен номер или идентификатор). Внимание: върнатият контакт да няма възможност да бъде променян!

*    извеждане на книгата с контакти подредена по даден критерий  (име, телефонен номер или идентификатор)

*    премахване на контакт


Упътване 1: Може да се използва наготово стандартния клас `std::string`.

Упътване 2: Може да се предефинира операцията за изход `<<` за тип `Contact*`, за да работи правилно извеждането на речник.

Забележка: за тази част от задачата не се изискват никакви усилия по управление на динамичната памет.

### Трета част: Динамична памет

За класа `ContactBook` да се реализира допълнителна логика, която да се грижи правилно за управлението на подаваните контакти. 
Считаме, че `ContactBook` “притежава” контактите, т.е. при добавяне на контакт създава негово копие, а при изтриване унищожава контакта.